#!/usr/bin/env python3
"""
API Migration Tools - Phase 4
Automated tools for migrating from legacy API to v2 consolidated endpoints
"""

import json
import re
from typing import Dict, List, Tuple, Optional
from pathlib import Path
import logging

logger = logging.getLogger(__name__)

class APIMigrationAnalyzer:
    """Analyze codebase for API usage and generate migration report"""
    
    def __init__(self, project_root: str = "."):
        self.project_root = Path(project_root)
        self.api_usage = {}
        self.migration_suggestions = []
        
    def analyze_codebase(self) -> Dict[str, Any]:
        """
        Scan codebase for API usage patterns
        
        Returns:
            Analysis report with migration suggestions
        """
        report = {
            'total_files_scanned': 0,
            'api_calls_found': 0,
            'deprecated_endpoints': {},
            'migration_required': [],
            'effort_estimate': 'Low'
        }
        
        # Define patterns to search for
        patterns = {
            'fetch': r'fetch\(["\']([^"\']+)["\']',
            'axios': r'axios\.(get|post|put|delete)\(["\']([^"\']+)["\']',
            'jquery': r'\$\.(ajax|get|post)\(\{[^}]*url:\s*["\']([^"\']+)["\']',
            'requests': r'requests\.(get|post|put|delete)\(["\']([^"\']+)["\']'
        }
        
        # Scan JavaScript, Python, and TypeScript files
        file_patterns = ['*.js', '*.py', '*.ts', '*.jsx', '*.tsx', '*.html']
        
        for pattern in file_patterns:
            for file_path in self.project_root.rglob(pattern):
                if 'node_modules' in str(file_path) or '.git' in str(file_path):
                    continue
                    
                report['total_files_scanned'] += 1
                self._analyze_file(file_path, patterns, report)
        
        # Calculate migration effort
        total_calls = report['api_calls_found']
        if total_calls > 100:
            report['effort_estimate'] = 'High'
        elif total_calls > 50:
            report['effort_estimate'] = 'Medium'
        
        return report
    
    def _analyze_file(self, file_path: Path, patterns: Dict, report: Dict):
        """Analyze a single file for API usage"""
        try:
            content = file_path.read_text(encoding='utf-8', errors='ignore')
            
            for pattern_name, pattern in patterns.items():
                matches = re.findall(pattern, content)
                
                for match in matches:
                    # Extract URL from match
                    if isinstance(match, tuple):
                        url = match[-1]
                    else:
                        url = match
                    
                    # Check if it's a deprecated endpoint
                    if '/api/' in url and '/api/v2/' not in url:
                        report['api_calls_found'] += 1
                        
                        endpoint = self._extract_endpoint(url)
                        if endpoint:
                            if endpoint not in report['deprecated_endpoints']:
                                report['deprecated_endpoints'][endpoint] = []
                            
                            report['deprecated_endpoints'][endpoint].append({
                                'file': str(file_path),
                                'pattern': pattern_name,
                                'line': self._find_line_number(content, url)
                            })
                            
        except Exception as e:
            logger.error(f"Error analyzing file {file_path}: {e}")
    
    def _extract_endpoint(self, url: str) -> Optional[str]:
        """Extract endpoint path from URL"""
        # Remove query parameters
        if '?' in url:
            url = url.split('?')[0]
        
        # Extract path after /api/
        if '/api/' in url:
            parts = url.split('/api/')
            if len(parts) > 1:
                return '/api/' + parts[1]
        
        return None
    
    def _find_line_number(self, content: str, search_text: str) -> int:
        """Find line number of text in content"""
        lines = content.split('\n')
        for i, line in enumerate(lines, 1):
            if search_text in line:
                return i
        return 0
    
    def generate_migration_script(self, report: Dict) -> str:
        """
        Generate automated migration script
        
        Args:
            report: Analysis report
            
        Returns:
            Migration script as string
        """
        script = []
        script.append("#!/usr/bin/env python3")
        script.append('"""')
        script.append("Automated API Migration Script")
        script.append("Generated by APIMigrationAnalyzer")
        script.append('"""')
        script.append("")
        script.append("import re")
        script.append("from pathlib import Path")
        script.append("")
        script.append("# Endpoint mappings")
        script.append("ENDPOINT_MAPPINGS = {")
        
        from src.api.v2.blueprint_integration import DEPRECATED_ENDPOINT_MAPPINGS
        
        for old, new in DEPRECATED_ENDPOINT_MAPPINGS.items():
            script.append(f'    "{old}": "{new}",')
        
        script.append("}")
        script.append("")
        script.append("def migrate_file(file_path: str):")
        script.append('    """Migrate API calls in a single file"""')
        script.append("    path = Path(file_path)")
        script.append("    content = path.read_text()")
        script.append("    original_content = content")
        script.append("")
        script.append("    # Replace deprecated endpoints")
        script.append("    for old_endpoint, new_endpoint in ENDPOINT_MAPPINGS.items():")
        script.append("        content = content.replace(old_endpoint, new_endpoint)")
        script.append("")
        script.append("    # Save if changed")
        script.append("    if content != original_content:")
        script.append("        path.write_text(content)")
        script.append('        print(f"Migrated: {file_path}")')
        script.append("        return True")
        script.append("    return False")
        script.append("")
        script.append("if __name__ == '__main__':")
        script.append("    # Files to migrate")
        script.append("    files_to_migrate = [")
        
        for endpoint, locations in report['deprecated_endpoints'].items():
            for location in locations:
                script.append(f'        "{location["file"]}",')
        
        script.append("    ]")
        script.append("")
        script.append("    migrated_count = 0")
        script.append("    for file_path in set(files_to_migrate):")
        script.append("        if migrate_file(file_path):")
        script.append("            migrated_count += 1")
        script.append("")
        script.append('    print(f"\\nMigration complete: {migrated_count} files updated")')
        
        return '\n'.join(script)


class ClientSDKGenerator:
    """Generate client SDKs for v2 API"""
    
    @staticmethod
    def generate_javascript_sdk() -> str:
        """Generate JavaScript/TypeScript SDK for v2 API"""
        sdk = []
        sdk.append("// Beverly Knits ERP API v2 SDK")
        sdk.append("// Auto-generated client library")
        sdk.append("")
        sdk.append("class BeverlyKnitsAPI {")
        sdk.append("  constructor(baseURL = '') {")
        sdk.append("    this.baseURL = baseURL;")
        sdk.append("    this.apiVersion = 'v2';")
        sdk.append("  }")
        sdk.append("")
        sdk.append("  // Helper method for API calls")
        sdk.append("  async request(endpoint, options = {}) {")
        sdk.append("    const url = `${this.baseURL}/api/${this.apiVersion}${endpoint}`;")
        sdk.append("    const response = await fetch(url, {")
        sdk.append("      ...options,")
        sdk.append("      headers: {")
        sdk.append("        'Content-Type': 'application/json',")
        sdk.append("        ...options.headers")
        sdk.append("      }")
        sdk.append("    });")
        sdk.append("")
        sdk.append("    if (!response.ok) {")
        sdk.append("      throw new Error(`API Error: ${response.status}`);")
        sdk.append("    }")
        sdk.append("")
        sdk.append("    const data = await response.json();")
        sdk.append("    return data.data || data;")
        sdk.append("  }")
        sdk.append("")
        sdk.append("  // Inventory methods")
        sdk.append("  async getInventory(params = {}) {")
        sdk.append("    const query = new URLSearchParams(params).toString();")
        sdk.append("    return this.request(`/inventory${query ? '?' + query : ''}`);")
        sdk.append("  }")
        sdk.append("")
        sdk.append("  async getYarnInventory() {")
        sdk.append("    return this.getInventory({ view: 'yarn' });")
        sdk.append("  }")
        sdk.append("")
        sdk.append("  async getShortages() {")
        sdk.append("    return this.getInventory({ view: 'shortage' });")
        sdk.append("  }")
        sdk.append("")
        sdk.append("  // Production methods")
        sdk.append("  async getProduction(params = {}) {")
        sdk.append("    const query = new URLSearchParams(params).toString();")
        sdk.append("    return this.request(`/production${query ? '?' + query : ''}`);")
        sdk.append("  }")
        sdk.append("")
        sdk.append("  async getProductionStatus() {")
        sdk.append("    return this.getProduction({ view: 'status' });")
        sdk.append("  }")
        sdk.append("")
        sdk.append("  async getProductionPlanning() {")
        sdk.append("    return this.getProduction({ view: 'planning' });")
        sdk.append("  }")
        sdk.append("")
        sdk.append("  async createProductionOrder(orderData) {")
        sdk.append("    return this.request('/production', {")
        sdk.append("      method: 'POST',")
        sdk.append("      body: JSON.stringify(orderData)")
        sdk.append("    });")
        sdk.append("  }")
        sdk.append("")
        sdk.append("  // Forecasting methods")
        sdk.append("  async getForecast(params = {}) {")
        sdk.append("    const query = new URLSearchParams(params).toString();")
        sdk.append("    return this.request(`/forecast${query ? '?' + query : ''}`);")
        sdk.append("  }")
        sdk.append("")
        sdk.append("  async triggerRetraining(model = 'ensemble') {")
        sdk.append("    return this.request('/forecast', {")
        sdk.append("      method: 'POST',")
        sdk.append("      body: JSON.stringify({ model })")
        sdk.append("    });")
        sdk.append("  }")
        sdk.append("")
        sdk.append("  // Analytics methods")
        sdk.append("  async getAnalytics(params = {}) {")
        sdk.append("    const query = new URLSearchParams(params).toString();")
        sdk.append("    return this.request(`/analytics${query ? '?' + query : ''}`);")
        sdk.append("  }")
        sdk.append("")
        sdk.append("  async getKPIs() {")
        sdk.append("    return this.getAnalytics({ category: 'kpi' });")
        sdk.append("  }")
        sdk.append("")
        sdk.append("  // Yarn methods")
        sdk.append("  async getYarn(params = {}) {")
        sdk.append("    const query = new URLSearchParams(params).toString();")
        sdk.append("    return this.request(`/yarn${query ? '?' + query : ''}`);")
        sdk.append("  }")
        sdk.append("")
        sdk.append("  async findYarnSubstitutes(yarnId) {")
        sdk.append("    return this.request('/yarn', {")
        sdk.append("      method: 'POST',")
        sdk.append("      body: JSON.stringify({")
        sdk.append("        action: 'find_substitutes',")
        sdk.append("        yarn_id: yarnId")
        sdk.append("      })")
        sdk.append("    });")
        sdk.append("  }")
        sdk.append("}")
        sdk.append("")
        sdk.append("// Export for use")
        sdk.append("if (typeof module !== 'undefined' && module.exports) {")
        sdk.append("  module.exports = BeverlyKnitsAPI;")
        sdk.append("}")
        
        return '\n'.join(sdk)
    
    @staticmethod
    def generate_python_sdk() -> str:
        """Generate Python SDK for v2 API"""
        sdk = []
        sdk.append('"""')
        sdk.append("Beverly Knits ERP API v2 SDK")
        sdk.append("Auto-generated Python client library")
        sdk.append('"""')
        sdk.append("")
        sdk.append("import requests")
        sdk.append("from typing import Dict, Any, Optional")
        sdk.append("from urllib.parse import urlencode")
        sdk.append("")
        sdk.append("")
        sdk.append("class BeverlyKnitsAPI:")
        sdk.append('    """Client for Beverly Knits ERP API v2"""')
        sdk.append("")
        sdk.append("    def __init__(self, base_url: str = 'http://localhost:5006'):")
        sdk.append("        self.base_url = base_url")
        sdk.append("        self.api_version = 'v2'")
        sdk.append("        self.session = requests.Session()")
        sdk.append("")
        sdk.append("    def _request(self, endpoint: str, method: str = 'GET', **kwargs) -> Dict[str, Any]:")
        sdk.append('        """Make API request"""')
        sdk.append("        url = f'{self.base_url}/api/{self.api_version}{endpoint}'")
        sdk.append("        ")
        sdk.append("        response = self.session.request(method, url, **kwargs)")
        sdk.append("        response.raise_for_status()")
        sdk.append("        ")
        sdk.append("        data = response.json()")
        sdk.append("        return data.get('data', data)")
        sdk.append("")
        sdk.append("    # Inventory methods")
        sdk.append("    def get_inventory(self, **params) -> Dict[str, Any]:")
        sdk.append('        """Get inventory data"""')
        sdk.append("        query = '?' + urlencode(params) if params else ''")
        sdk.append("        return self._request(f'/inventory{query}')")
        sdk.append("")
        sdk.append("    def get_yarn_inventory(self) -> Dict[str, Any]:")
        sdk.append('        """Get yarn inventory"""')
        sdk.append("        return self.get_inventory(view='yarn')")
        sdk.append("")
        sdk.append("    def get_shortages(self) -> Dict[str, Any]:")
        sdk.append('        """Get shortage analysis"""')
        sdk.append("        return self.get_inventory(view='shortage')")
        sdk.append("")
        sdk.append("    # Production methods")
        sdk.append("    def get_production(self, **params) -> Dict[str, Any]:")
        sdk.append('        """Get production data"""')
        sdk.append("        query = '?' + urlencode(params) if params else ''")
        sdk.append("        return self._request(f'/production{query}')")
        sdk.append("")
        sdk.append("    def create_production_order(self, order_data: Dict[str, Any]) -> Dict[str, Any]:")
        sdk.append('        """Create new production order"""')
        sdk.append("        return self._request('/production', method='POST', json=order_data)")
        sdk.append("")
        sdk.append("    # Forecasting methods")
        sdk.append("    def get_forecast(self, **params) -> Dict[str, Any]:")
        sdk.append('        """Get forecast data"""')
        sdk.append("        query = '?' + urlencode(params) if params else ''")
        sdk.append("        return self._request(f'/forecast{query}')")
        sdk.append("")
        sdk.append("    def trigger_retraining(self, model: str = 'ensemble') -> Dict[str, Any]:")
        sdk.append('        """Trigger model retraining"""')
        sdk.append("        return self._request('/forecast', method='POST', json={'model': model})")
        sdk.append("")
        sdk.append("    # Analytics methods")
        sdk.append("    def get_analytics(self, **params) -> Dict[str, Any]:")
        sdk.append('        """Get analytics data"""')
        sdk.append("        query = '?' + urlencode(params) if params else ''")
        sdk.append("        return self._request(f'/analytics{query}')")
        sdk.append("")
        sdk.append("    def get_kpis(self) -> Dict[str, Any]:")
        sdk.append('        """Get KPI metrics"""')
        sdk.append("        return self.get_analytics(category='kpi')")
        sdk.append("")
        sdk.append("    # Yarn methods")
        sdk.append("    def get_yarn(self, **params) -> Dict[str, Any]:")
        sdk.append('        """Get yarn data"""')
        sdk.append("        query = '?' + urlencode(params) if params else ''")
        sdk.append("        return self._request(f'/yarn{query}')")
        sdk.append("")
        sdk.append("    def find_yarn_substitutes(self, yarn_id: str) -> Dict[str, Any]:")
        sdk.append('        """Find yarn substitutes"""')
        sdk.append("        return self._request('/yarn', method='POST', json={")
        sdk.append("            'action': 'find_substitutes',")
        sdk.append("            'yarn_id': yarn_id")
        sdk.append("        })")
        
        return '\n'.join(sdk)


def run_migration_analysis(project_root: str = ".") -> None:
    """
    Run migration analysis and generate reports
    
    Args:
        project_root: Root directory of the project
    """
    analyzer = APIMigrationAnalyzer(project_root)
    
    print("Analyzing codebase for API usage...")
    report = analyzer.analyze_codebase()
    
    print("\n=== API Migration Analysis Report ===")
    print(f"Files scanned: {report['total_files_scanned']}")
    print(f"API calls found: {report['api_calls_found']}")
    print(f"Deprecated endpoints: {len(report['deprecated_endpoints'])}")
    print(f"Migration effort: {report['effort_estimate']}")
    
    if report['deprecated_endpoints']:
        print("\n=== Deprecated Endpoints Found ===")
        for endpoint, locations in report['deprecated_endpoints'].items():
            print(f"\n{endpoint}:")
            for loc in locations[:3]:  # Show first 3 occurrences
                print(f"  - {loc['file']}:{loc['line']}")
            if len(locations) > 3:
                print(f"  ... and {len(locations) - 3} more")
    
    # Generate migration script
    if report['api_calls_found'] > 0:
        script = analyzer.generate_migration_script(report)
        script_path = Path("migrate_api.py")
        script_path.write_text(script)
        print(f"\n✅ Migration script generated: {script_path}")
    
    # Generate SDKs
    js_sdk = ClientSDKGenerator.generate_javascript_sdk()
    py_sdk = ClientSDKGenerator.generate_python_sdk()
    
    Path("beverly_knits_api.js").write_text(js_sdk)
    Path("beverly_knits_api.py").write_text(py_sdk)
    
    print("✅ JavaScript SDK generated: beverly_knits_api.js")
    print("✅ Python SDK generated: beverly_knits_api.py")


if __name__ == "__main__":
    run_migration_analysis()

# Export main components
__all__ = [
    'APIMigrationAnalyzer',
    'ClientSDKGenerator',
    'run_migration_analysis'
]